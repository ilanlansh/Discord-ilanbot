(function(scope,undefined){

    /**
     * The Queue object provides a means to queue up functional tasks
     * and have them execute in an asynchronous fashion with optional parallelism
     * @example
     * var Q = Queue(2);
     *
     * @example
     * var Q = Queue();
     *
     * @example
     * var Q = new Queue(2);
     *
     * @example
     * var Q = new Queue();
     *
     * @name Queue
     * @constructor
     * @class
     * @param {Integer} [workers=1] Sets the number of workers, defaulted to 1
     * @returns {Queue} A new queue object
     */
    var Queue = function(workers){
            var privateMembers = {}, //prototype private members namespace
                publicMembers = this; //prototype public members namespace

            workers = Math.round(workers) >-1 ? Math.round(workers) : 1; //dirty-sterilize workers


            privateMembers.taskStack = [];
            privateMembers.callbackStack = [];
            privateMembers.threadCount = 0;
            privateMembers.isRunning = false;

            /**
             * The callbackWorkerFactory function  returns a functional processor for the Callback Stack
             *
             * @name Queue#callbackWorkerFactory
             * @function
             * @private
             */
            privateMembers.callbackWorkerFactory = function(){
                var start = function(){
                    var processor = setInterval(function(){
                        if(privateMembers.threadCount < workers){ //limit the number of threads to the worker limit
                            if(privateMembers.callbackStack.length > 0){ //enter general case
                                privateMembers.threadCount++; //increment the thread count
                                privateMembers.callbackStack.pop()(); //pop and execute a callback
                            }
                            else{ //enter base case
                                clearInterval(processor); //suicide this worker
                            }
                        }
                    },0);
                };

                var check = setInterval(function(){
                    if(privateMembers.taskStack.length < 1 && privateMembers.threadCount === 0){
                        clearInterval(check);
                        start();
                    }
                },0);

            };

            /**
             * The taskWorkerFactory function returns a functional processor for the Task Stack
             *
             * @name Queue#taskWorkerFactory
             * @function
             * @private
             */
            privateMembers.taskWorkerFactory = function(){
                var processor = setInterval(function(){
                    privateMembers.isRunning = true;
                    if(privateMembers.threadCount < workers){ //limit the number of threads to the worker limit
                        if(privateMembers.taskStack.length > 0){ //enter general case
                            privateMembers.threadCount++; //increment the thread count
                            privateMembers.taskStack.pop()(); //pop and execute a task
                        }
                        else{ //enter base case
                            clearInterval(processor); //suicide this worker
                        }
                    }
                },0);
            };

            /**
             * The size function returns the current length of the stack, not including executed and in-flight tasks
             *
             * @example
             * var Q = Queue();                              false
             * Q.addTask(function(){
             *      console.log('hello world!');
             * });
             * console.log(Q.size); // => 1
             *
             * @name Queue#size
             * @function
             * @public
             * @returns {Number} Returns the current length of the stack
             */

            publicMembers.size = function(){
                return privateMembers.taskStack.length;
            };

            /**
             * The isRunning function returns the current state of the queue;
             * That is false for idle, true for running.
             *
             * @example
             * var Q = Queue(),
             *     taskFactory = function(str){ //A simple console.log function factory!
             *         return new Function(){
             *             console.log(str);
             *         };
             *     },
             *     i;
             *
             * for(i=0;i<9999;i++){ //add a bunch of tasks
             *      Q.addTask(taskFactory("Hello World!")); //'Hello World' will output via console for each task
             * }
             *
             * Q.start();
             * setInterval(function(){
             *     if(!Q.isRunning){
             *          console.log("Queue is done!"); //this will output once the queue is empty!
             *     }
             * },0);
             *
             * @name Queue#isRunning
             * @function
             * @public
             * @returns {Boolean} Returns true if running or false if idle
             */
            publicMembers.isRunning = function(){
                return privateMembers.isRunning;
            };


            /**
             * The inFlight function returns the number of tasks currently being executed
             *
             * @example
             * var Q = Queue();
             *
             * setInterval(function(){
             *      if(Q.inFlight>0){
             *          console.log(Q.inFlight);
             *      }
             * },0);
             *
             * Q.addTask(function(){
             *     console.log("Hello World!");
             * };
             * Q.addTask(function(){
             *     console.log("Hello World!");
             * };
             * Q.addTask(function(){
             *     console.log("Hello World!");
             * };
             * Q.addTask(function(){
             *     console.log("Hello World!");
             * };
             *
             * Q.start(); //=> 1
             *            //   2
             *            //   1
             *
             * @name Queue#inFlight
             * @function
             * @public
             * @returns {Integer} Returns the number of tasks currently being executed
             */
            publicMembers.inFlight = function(){
                return privateMembers.threadCount;
            };

            /**
             * The addTask function adds a task to the queue.
             *
             * @example
             * var Q = Queue();
             * Q.addTask(function(){
             *      console.log("Hello World!");
             * });
             * Q.start(); // => Hello World!
             *
             * @name Queue#addTask
             * @function
             * @public
             * @param {Function} task A task to execute
             * @param {Object} [context = this] An objectual execution context, defaults to this instance of the Queue
             * @returns {Queue} Returns this instance of the Queue
             */
            publicMembers.addTask = function(task,context){
                if(typeof task == 'function'){
                    privateMembers.taskStack.push(function(){
                        setTimeout(function(){
                            task.call(context || this);
                            privateMembers.threadCount--; //decrement the thread count post-exec
                        },0);
                    });
                }
                else{
                    console.error("Queue.addTask expected type 'function' as first parameter; instead received type '"+typeof task+"'");
                }

                return this;
            };

            /**
             * The addCallback function adds a callback to be executed once the Queue is empty
             * @example
             * var Q = Queue():
             * Q.addTask(function(){
             *     console.log("Foo");
             * });
             * Q.addTask(function(){
             *     console.log("Bar");
             * });
             * Q.addCallback(function(){
             *     console.log("Hello");
             * });
             * Q.addCallback(function(){
             *     console.log("World!");
             * });
             *
             * Q.start(); //=> Foo
             *            //   Bar
             *            //   Hello
             *            //   World!
             *
             * @name Queue#addCallback
             * @function
             * @public
             * @param {Function} callback The callback to be executed once the Queue is empty
             * @param {Object} [context = this] context An objectual execution context, defaults to this instance of the Queue
             * @returns {Queue} Returns this instance of the Queue
             */
            publicMembers.addCallback = function(callback,context){
                if(typeof callback == 'function'){
                    privateMembers.callbackStack.push(function(){
                        setTimeout(function(){
                            callback.call(context || this);
                            privateMembers.threadCount--; //decrement the thread count post-exec

                            if(privateMembers.callbackStack.length < 1 && privateMembers.threadCount < 1){ //if this is the last callback worker
                                privateMembers.isRunning = false; //stop runnin
                            }
                        });
                    });
                }

                return this;
            };

            /**
             * The start function begins processing of the Queue
             * @example
             * var Q = Queue();
             *
             * Q.addTask(function(){
             *      console.log("Hello World!");
             * });
             *
             * Q.start(); // => Hello World!
             *
             * @name Queue#start
             * @function
             * @public
             * @returns {Queue} Returns this instance of the Queue
             */
            publicMembers.start = function(){
                var i;

                if(privateMembers.threadCount < 1){ //only start if we aren't already started
                    privateMembers.taskWorkerFactory(); //spawn a worker
                    privateMembers.callbackWorkerFactory(); //begin watching for completion
                }

                return this;
            };

            if(!(this instanceof arguments.callee)){  //handle factory construction
                return new Queue(workers);
            }
        },

    /**
     * The bind function binds the Queue constructor to either the 'window' or 'exports' object
     */
        bind = function(scope){
            if(scope !== null){
                scope.Queue = Queue;
            }
            else{
                throw new Error("Cannot find appropriate scope for binding; 'window' and 'exports' are undefined!");
            }
        };

    bind(scope);
}(typeof exports != 'undefined' && exports !== null ? exports : (typeof window != 'undefined' ? window : null)));
